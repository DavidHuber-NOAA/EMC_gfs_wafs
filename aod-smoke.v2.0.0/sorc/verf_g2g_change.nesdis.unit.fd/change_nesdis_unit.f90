PROGRAM CHANGE_NESDIS_UNIT
IMPLICIT NONE
INTEGER, PARAMETER :: IMAX=801, JMAX=534
INTEGER, PARAMETER :: MAXDATA=IMAX*JMAX
INTEGER, PARAMETER :: JPDS_DIM = 200    ! default SIZE for JPDS array in libw3.a
REAL,ALLOCATABLE,DIMENSION(:) :: DATA, VAR
LOGICAL*1, ALLOCATABLE, DIMENSION(:) :: LB
CHARACTER (LEN=11):: ENVVAR
CHARACTER (LEN=120) :: FNAME, FNAME1, OUTFILE, CYCLE
CHARACTER (LEN=120), DIMENSION(JPDS_DIM) :: CKPDS
INTEGER, DIMENSION(JPDS_DIM) :: KPDS, KGDS
INTEGER, DIMENSION( 5) :: KENS
INTEGER, DIMENSION( 2) :: KPROB
REAL,    DIMENSION( 2) :: XPROB
INTEGER, DIMENSION(16) :: KCLUST
INTEGER, DIMENSION(80) :: KMEMBR
REAL :: BMAX, BMIN
INTEGER :: I, J, K, L, M, N, JF, IIN, IOUT
INTEGER :: ICNT, ISEEK, LLGRIB, LLSKIP, IERR
LOGICAL :: CHKFLE

JF = MAXDATA

!
! Ho-Chun Huang 07/02/07 change kpds(22) from 5 to 3, best test values
!
ALLOCATE(VAR(JF))
ALLOCATE(DATA(JF))
ALLOCATE(LB(JF))

!ZZ READ(5,*) INFILE
!ZZ CYCLE=INFILE(13:14)

!ZZ WRITE(*,*) TRIM(INFILE),'  ', TRIM(CYCLE)
!ZZ INQUIRE(EXIST=CHKFLE,FILE=TRIM(INFILE))
!ZZ IF ( .NOT. CHKFLE ) THEN
!ZZ   WRITE(*,'('' PROCESSED FILE '',A, '' NOT EXISTED'')') TRIM(INFILE)
!ZZ ELSE

IIN=10

ENVVAR='XLFUNIT_   '
WRITE(ENVVAR(9:10),FMT='(I2)') IIN
CALL GETENV(ENVVAR,FNAME)

!ZZ CALL BAOPENR(IIN,TRIM(INFILE),IERR)
CALL BAOPENR(IIN,FNAME,IERR)
ISEEK=0
CALL SKGB(IIN,ISEEK,LLGRIB,LLSKIP)

DO WHILE(LLGRIB > 0)  ! llgrib

  CALL RDGB(IIN,LLGRIB,LLSKIP,KPDS,KGDS,JF,LB,VAR)
  CALL SKGB(IIN,ISEEK,LLGRIB,LLSKIP)

  IF(KPDS(5) == 89) THEN
    DO I = 1, 25
      WRITE(CKPDS(I),*)KPDS(I)
    END DO
    WRITE(*,'(''KPDS = '', 25(A))') (TRIM(CKPDS(I)),I=1,25)
!    write(*,*) 'kgds=', kgds
    DATA=VAR*1.0E9                     !unit from kg/m3 -> micro-gram/m3
  END IF

ENDDO       ! end of while loop for llgrib

CALL BACLOSE(IIN,IERR)

IOUT=50

ENVVAR='XLFUNIT_   '
WRITE(ENVVAR(9:10),FMT='(I2)') IOUT
CALL GETENV(ENVVAR,FNAME1)
!ZZ WRITE(OUTFILE,'(''G13.t'',A,''z.f00'')') TRIM(CYCLE)
CALL BAOPEN(IOUT,FNAME1,IERR)
KPDS(5) = 89
KPDS(6) = 105
KPDS(7) = 5000
!
! CHANGE DECIMAL SCALING, BECAUE ALEADY MULTIPLY BY 1.0E+09
!
KPDS(22) = 3

BMAX=-1.E+20
BMIN= 1.E+20
VAR=-99.
ICNT = 0
DO I=1,JF
  IF(DATA(I) == -1.0) THEN
    VAR(I)= DATA(I)
  ELSE IF(DATA(I) == -2.0 .OR. DATA(I) == -3.0) THEN
    VAR(I)= 1.0E-6
  ELSE IF (DATA(I) == -9.0) THEN
    VAR(I)=DATA(I)
  ELSE
    VAR(I)=DATA(I)
  END IF
  IF ( VAR(I) > BMAX ) BMAX = VAR(I)
  IF ( VAR(I) < BMIN ) BMIN = VAR(I)
END DO
PRINT *, 'MAX VALUE = ', BMAX
PRINT *, 'MIN VALUE = ', BMIN

KPROB(1) = -1         !: OCT 46
KPROB(2) = -1         !: OCT 47
XPROB(1) = -1.        !: OCT 48-51
XPROB(2) = -1.        !: OCT 52-55
KENS(1) = -1          !: OCT 41
KENS(2) = -1           !: OCT 42
KENS(3) = -1           !: OCT 43
KENS(4) = -1
KENS(5) = 255
KCLUST(1)= 1

!ZZ WRITE(*,'(''PACKING '',A)') TRIM(OUTFILE)
WRITE(*,'(''PACKING '',A)') FNAME1
! write(*,*) 'kpds=',kpds

CALL PUTGBEX(IOUT,JF,KPDS,KGDS,KENS,KPROB,XPROB,KCLUST,KMEMBR,LB,VAR,IERR)

CALL BACLOSE(IOUT,IERR)

!ZZ END IF

CONTAINS


!**********************************************************************
SUBROUTINE RDGB(LUGB,LGRIB,LSKIP,KPDS,KGDS,NDATA,LBMS,DATA)
IMPLICIT NONE
!
!  READ GRIB FILE
!  INPUT
!    LUGB - LOGICAL UNIT TO READ
!    LGRIB - LENGTH OF GRIB RECORD
!    LSKIP - BYTES TO SKIP FOR GRIB RECORD
!  OUTPUT
!    KPDS(22) - UNPACKED PRODUCT DEFINITION SECTION
!    KGDS(20) - UNPACKED GRID DEFINITION SECTION
!    NDATA    - NUMBER OF DATA POINTS
!    LBMS(NDATA) - LOGICAL BIT MAP
!    DATA(NDATA) - DATA UNPACKED
!
INTEGER, DIMENSION(:), INTENT(OUT) :: KPDS, KGDS
LOGICAL*1, DIMENSION(:), INTENT(OUT) :: LBMS
REAL, DIMENSION(:), INTENT(OUT) :: DATA
INTEGER, INTENT(IN) :: LUGB, LSKIP, LGRIB
INTEGER, INTENT(OUT) :: NDATA

CHARACTER (LEN=1), DIMENSION(LGRIB) ::  GRIB
INTEGER, DIMENSION(20) :: KPTR
INTEGER :: LREAD, IRET

NDATA=0
CALL BAREAD(LUGB,LSKIP,LGRIB,LREAD,GRIB)
IF ( LREAD < LGRIB ) RETURN
CALL W3FI63(GRIB,KPDS,KGDS,LBMS,DATA,KPTR,IRET)
IF(IRET /= 0) RETURN
NDATA=KPTR(10)
RETURN
END SUBROUTINE RDGB

!********************************************
!********************************************
SUBROUTINE SKGB(LUGB,ISEEK,LGRIB,LSKIP)
IMPLICIT NONE
!
!  SEEK FOR NEXT GRIB1 RECORD WITHIN THE NEXT LSEEK=4096 BYTES
!  INPUT
!    LUGB  - LOGICAL UNIT TO READ
!    ISEEK - BYTES TO SKIP BEFORE SEARCH (SET TO 0 AT START)
!  OUTPUT
!    ISEEK - NUMBER OF BYTES READ SO FAR
!    LGRIB - LENGTH OF GRIB RECORD (0 IF NOT FOUND)
!    LSKIP - BYTES TO SKIP FOR GRIB RECORD
!
INTEGER, PARAMETER :: LSEEK=4096
CHARACTER (LEN=LSEEK) :: C
INTEGER, INTENT(IN) :: LUGB
INTEGER, INTENT(INOUT) :: ISEEK
INTEGER, INTENT(OUT):: LSKIP, LGRIB
INTEGER :: I, LREAD, IRET, MOVA2I

CALL BAREAD(LUGB,ISEEK,LSEEK,LREAD,C)
DO I=0,LREAD-8
  IF(C(I+1:I+4) == 'GRIB'.AND.MOVA2I(C(I+8:I+8)) == 1) THEN
    LGRIB=MOVA2I(C(I+5:I+5))*65536 &
               +MOVA2I(C(I+6:I+6))*256   &
               +MOVA2I(C(I+7:I+7))
    LSKIP=ISEEK+I
    ISEEK=LSKIP+LGRIB
    RETURN
  ENDIF
ENDDO
LGRIB=0
LSKIP=0
ISEEK=ISEEK+LSEEK
!      CALL W3TAGE('SREF_COM_GRIB')
RETURN
END SUBROUTINE SKGB

END PROGRAM CHANGE_NESDIS_UNIT
